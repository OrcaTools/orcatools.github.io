{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome UNDER ACTIVE DEVELOPMENT OrcaTools is under active development. Any information here is subject to change without warning, until we reach our first stable release. Any binaries downloaded from this site are \"as is\" and you use them at your own risk. OrcaTools Use Cases The outline below illustrates some high level use cases for OrcaTools. Config Management - bootstrap machine configuration at startup - prevent misconfigurations on day N of the machine's lifecycle - automate and manage operations across a fleet of machines Task Management - automated testing - automated deployments - remote task execution - any type of ci/cd pipeline work Event Management - respond to host events in realtime - manage condition response policies across a fleet of machines - early intrusion detection capabilities Secrets Management - manage hundreds of secrets inside of single encrypted file - easily export secrets as environment variables - can optionally require multiple passwords to unlock the lockbox - lockbox supports mfa Supported Operating Systems OrcaTools officially supports the following linux operating systems: Operating System Supported Versions Debian Stretch, Jessie, Buster, Bullseye Ubuntu 14.04, 16.04, 18.04, 20.04, 20.10 RHEL 7, 8 CentOS 6, 7, 8 Alpine 3 NOTE: While our tools may work on other distros not mentioned here just fine, we are only listing the distros we actively test against. As we add support for other distros or versions, we'll update this table to reflect that support.","title":"Welcome"},{"location":"#welcome","text":"UNDER ACTIVE DEVELOPMENT OrcaTools is under active development. Any information here is subject to change without warning, until we reach our first stable release. Any binaries downloaded from this site are \"as is\" and you use them at your own risk.","title":"Welcome"},{"location":"#orcatools-use-cases","text":"The outline below illustrates some high level use cases for OrcaTools.","title":"OrcaTools Use Cases"},{"location":"#config-management","text":"- bootstrap machine configuration at startup - prevent misconfigurations on day N of the machine's lifecycle - automate and manage operations across a fleet of machines","title":"Config Management"},{"location":"#task-management","text":"- automated testing - automated deployments - remote task execution - any type of ci/cd pipeline work","title":"Task Management"},{"location":"#event-management","text":"- respond to host events in realtime - manage condition response policies across a fleet of machines - early intrusion detection capabilities","title":"Event Management"},{"location":"#secrets-management","text":"- manage hundreds of secrets inside of single encrypted file - easily export secrets as environment variables - can optionally require multiple passwords to unlock the lockbox - lockbox supports mfa","title":"Secrets Management"},{"location":"#supported-operating-systems","text":"OrcaTools officially supports the following linux operating systems: Operating System Supported Versions Debian Stretch, Jessie, Buster, Bullseye Ubuntu 14.04, 16.04, 18.04, 20.04, 20.10 RHEL 7, 8 CentOS 6, 7, 8 Alpine 3 NOTE: While our tools may work on other distros not mentioned here just fine, we are only listing the distros we actively test against. As we add support for other distros or versions, we'll update this table to reflect that support.","title":"Supported Operating Systems"},{"location":"downloads/","text":"OrcaTools Downloads orca orca is a lightweight cli tool for executing orcascripts. Arch Link x86 https://downloads.orcatools.io/orca.tar.gz orcasrvr orcasrvr provides a REST API interface for task based execution. A 'Task' is just Orcascript, with some management structure around it. Arch Link x86 https://downloads.orcatools.io/orcasrvr.tar.gz orcaem orcaem is the Orca Event Manager. Its a lightweight agent that can monitor host metrics, and respond to host events in realtime. Arch Link x86 https://downloads.orcatools.io/orcaem.tar.gz lockbox lockbox provides secure and portable storage for saving and sharing secrets. It natively integrates with all other OrcaTools. Arch Link x86 https://downloads.orcatools.io/lockbox.tar.gz","title":"Downloads"},{"location":"downloads/#orcatools-downloads","text":"","title":"OrcaTools Downloads"},{"location":"downloads/#orca","text":"orca is a lightweight cli tool for executing orcascripts. Arch Link x86 https://downloads.orcatools.io/orca.tar.gz","title":"orca"},{"location":"downloads/#orcasrvr","text":"orcasrvr provides a REST API interface for task based execution. A 'Task' is just Orcascript, with some management structure around it. Arch Link x86 https://downloads.orcatools.io/orcasrvr.tar.gz","title":"orcasrvr"},{"location":"downloads/#orcaem","text":"orcaem is the Orca Event Manager. Its a lightweight agent that can monitor host metrics, and respond to host events in realtime. Arch Link x86 https://downloads.orcatools.io/orcaem.tar.gz","title":"orcaem"},{"location":"downloads/#lockbox","text":"lockbox provides secure and portable storage for saving and sharing secrets. It natively integrates with all other OrcaTools. Arch Link x86 https://downloads.orcatools.io/lockbox.tar.gz","title":"lockbox"},{"location":"Config%20Management/","text":"Intro Orcascript was specifically engineered for Config Management tasks. There are several other tools available, and some that are quite popular, for config management operations. As of this writing, probably the most popular of those tools is Ansible. In this brief intro, I'd like to outline some of the key differences between Ansible, and Orcascript. Ansible playbooks are written in YAML. Ansible does try to provide some logical operations within it's specific flavor of YAML, but its not a scripting language. It does lack some control that many would find very useful. Orcascript, on the other hand, is a full blown scripting language, designed for automation tasks! Check out the Syntax Guide to see all of the features! This means when you need a if statement, its there. When you need a for loop, its there. When you need to easily interact with REST APIs, its there. Some of these basic things that we take for granted, just arent available in YAML, and require additional overhead within a YAML processor (like Ansible) to address these issues. Limitations such as this do cause intersting issues, and in part, is what helped inspire Orcascript to begin with. Orcascript, bypasses all of these issues because it's not designed around YAML. Ansible playbooks / roles are often times organized in a mutli-directory structure. Standardization is great, but sometimes having to dig through multiple directories, or comb through way too many yaml files isn't ideal. Orcascript has a single file approach to help reduce the directory & file sprawl. Ansible is agentless, and it connects to target machines via SSH to execute playbooks. This approach is ideal, as it doesn't require any setup to run against a known set of targets. It's one of my favorite things about Ansible. Because at the end of the day, it is just a script, there are many ways one could execute an orcascript. The only underlying assumption is that the orca binary has been installed to the path on the machine that will execute the orcascript. The same is true for Python, Bash, Node, etc. The difference is that the orca binary would not be installed on the machine by default. Assuming that orca is in the path, for cloud environments, where userdata (cloudinit) is readily available, one could simply download the desired script and execute it on the machine at startup to bootstrap it into a desired configuration. Orcascript has a unified scripting interface, so that no matter which supported distro you choose to run on, typically, the same script can run across any supported distro. For more advanced use cases, the orca binary can also connect to target machines over SSH (similar to Ansible) and execute a given orcascript on remote machines. Continue reading about Declaritive State Defintions to better understand some of the differences between Orcascript and Ansible.","title":"Intro"},{"location":"Config%20Management/#intro","text":"Orcascript was specifically engineered for Config Management tasks. There are several other tools available, and some that are quite popular, for config management operations. As of this writing, probably the most popular of those tools is Ansible. In this brief intro, I'd like to outline some of the key differences between Ansible, and Orcascript. Ansible playbooks are written in YAML. Ansible does try to provide some logical operations within it's specific flavor of YAML, but its not a scripting language. It does lack some control that many would find very useful. Orcascript, on the other hand, is a full blown scripting language, designed for automation tasks! Check out the Syntax Guide to see all of the features! This means when you need a if statement, its there. When you need a for loop, its there. When you need to easily interact with REST APIs, its there. Some of these basic things that we take for granted, just arent available in YAML, and require additional overhead within a YAML processor (like Ansible) to address these issues. Limitations such as this do cause intersting issues, and in part, is what helped inspire Orcascript to begin with. Orcascript, bypasses all of these issues because it's not designed around YAML. Ansible playbooks / roles are often times organized in a mutli-directory structure. Standardization is great, but sometimes having to dig through multiple directories, or comb through way too many yaml files isn't ideal. Orcascript has a single file approach to help reduce the directory & file sprawl. Ansible is agentless, and it connects to target machines via SSH to execute playbooks. This approach is ideal, as it doesn't require any setup to run against a known set of targets. It's one of my favorite things about Ansible. Because at the end of the day, it is just a script, there are many ways one could execute an orcascript. The only underlying assumption is that the orca binary has been installed to the path on the machine that will execute the orcascript. The same is true for Python, Bash, Node, etc. The difference is that the orca binary would not be installed on the machine by default. Assuming that orca is in the path, for cloud environments, where userdata (cloudinit) is readily available, one could simply download the desired script and execute it on the machine at startup to bootstrap it into a desired configuration. Orcascript has a unified scripting interface, so that no matter which supported distro you choose to run on, typically, the same script can run across any supported distro. For more advanced use cases, the orca binary can also connect to target machines over SSH (similar to Ansible) and execute a given orcascript on remote machines. Continue reading about Declaritive State Defintions to better understand some of the differences between Orcascript and Ansible.","title":"Intro"},{"location":"Config%20Management/modules/","text":"Config Management Modules Config Management Categories When you think about it, most config management task will fall within 1 of the following 3 categories. Packages Files / Directories Services Packages Automating the configuration of applications sometimes (ok, most times) requires installing some underlying packges. This is one of the primary use cases for other config management tools such as Puppet, Chef, Ansible, or SaltStack. They all handle it in slightly different ways, but being able to install, uninstall, and upgrade packages is a definite requirement of any configuration management system. In order to handle all package related tasks, Orcascript has a package module that ships with the stdlib. This means that there is nothing to import, or configure for managing package related tasks directly within Orcascript. Below are some examples of the methods provided by the package module. package . install ( \"<packageName>\" , \"<pacakgeVersion>\" ) package . installed ( \"<packageName>\" , \"<pacakgeVersion>\" ) package . upgrade ( \"<packageName>\" , \"<pacakgeVersion>\" ) package . uninstall ( \"<packageName>\" ) Simple, right? Orcascript also provides a common absstraction layer on top of the underlying differences between Linux distros. So, no matter which (supported) version of linux you are running the script on, it will always run the same way. Warning If you write your scripts in such a way that you are using package names that are specific to a given distro, then that particular statatement will fail on versions of linux that do not support that particular package name. NOTE: This only matters if you want the same script to run on multiple distros. If you are only targeting a single platform, then this warning can be safely ignored. In such cases where you would like to support multiple distros with a single script, while still using specific package names and/or versions, you can always use the included host module to determine the underlying os. Then, simply switch based on host.family within your script, and provide the statement specific to that platform. Here is a psuedo snippet of what that could look like: switch ( host . family ) { case \"debian\" : package . install ( \"<specific debian/ubuntu pacakge>\" , \"<specific version (optional)>\" ) case \"rhel\" : package . install ( \"<specific rhel/centos pacakge>\" , \"<specific version (optional)>\" ) case \"alpine\" : package . install ( \"<specific alpine pacakge>\" , \"<specific version (optional)>\" ) } Files & Directories When configuring a box, it is almost always required to write a configuration file to a path eg. /etc/someapp/somedir While other scripting languages provide this functionality, orcascript has went above and beyond to make this as easy as possible, with as little code as possible. The orcascript stdlib ships with an os module that provides methods such as isfile , isdir , mkdir , read , write and many, many more, that will handle all of the the operations that come with managing a filesystem. In addition to the os module, the stdlib also ships with a template module that provides template related methods such as render that will allow scripts to easily render templated configuration files in their proper directories, with the desired contents in place. For example, if you needed to create a file, ie /etc/some-app/some.conf , you could use the template module like so: // read in our example template file to a variable called 'tpl' tpl := os . read ( \"/path/to/my/config.tpl\" ) // define some example vars, // NOTE: you can load vars from many different sources. // NOTE: they don't have to be inline, like this. vars := { \"somekey\" : \"someval\" , \"someOtherKey\" : \"someOtherVal\" } // once you have a template, and some vars, you can use the render method. // this will write the file to the specified path, with the desired values // injected into the formatted template. template . render ( tpl , vars , \"/etc/some-app/some.conf\" ) Orcascript strives very hard to make it easy to manage any file system related task that you might encounter while attempting to write automation. Services The final \"general\" category that configuration management tasks usually fall into are services. You may need to start, stop, restart or check the status of a given service. Orcascript makes this easy! Yep, you probably guessed it. The orcascript stdlib ships with a service module that exposes methods for each of those common operations. Orcascript also provides an additional abstraction layer across the various system managers. This includes, System V, systemd and others. Here are some examples of the methods that the service module provides: service . start ( \"<serviceName>\" ) service . stop ( \"<serviceName>\" ) service . restart ( \"<serviceName>\" ) service . status ( \"<serviceName>\" ) service . enable ( \"<serviceName>\" ) service . disable ( \"<serviceName>\" ) service . isup ( \"<serviceName>\" ) service . isdown ( \"<serviceName>\" )","title":"Config Management Modules"},{"location":"Config%20Management/modules/#config-management-modules","text":"","title":"Config Management Modules"},{"location":"Config%20Management/modules/#config-management-categories","text":"When you think about it, most config management task will fall within 1 of the following 3 categories. Packages Files / Directories Services","title":"Config Management Categories"},{"location":"Config%20Management/modules/#packages","text":"Automating the configuration of applications sometimes (ok, most times) requires installing some underlying packges. This is one of the primary use cases for other config management tools such as Puppet, Chef, Ansible, or SaltStack. They all handle it in slightly different ways, but being able to install, uninstall, and upgrade packages is a definite requirement of any configuration management system. In order to handle all package related tasks, Orcascript has a package module that ships with the stdlib. This means that there is nothing to import, or configure for managing package related tasks directly within Orcascript. Below are some examples of the methods provided by the package module. package . install ( \"<packageName>\" , \"<pacakgeVersion>\" ) package . installed ( \"<packageName>\" , \"<pacakgeVersion>\" ) package . upgrade ( \"<packageName>\" , \"<pacakgeVersion>\" ) package . uninstall ( \"<packageName>\" ) Simple, right? Orcascript also provides a common absstraction layer on top of the underlying differences between Linux distros. So, no matter which (supported) version of linux you are running the script on, it will always run the same way. Warning If you write your scripts in such a way that you are using package names that are specific to a given distro, then that particular statatement will fail on versions of linux that do not support that particular package name. NOTE: This only matters if you want the same script to run on multiple distros. If you are only targeting a single platform, then this warning can be safely ignored. In such cases where you would like to support multiple distros with a single script, while still using specific package names and/or versions, you can always use the included host module to determine the underlying os. Then, simply switch based on host.family within your script, and provide the statement specific to that platform. Here is a psuedo snippet of what that could look like: switch ( host . family ) { case \"debian\" : package . install ( \"<specific debian/ubuntu pacakge>\" , \"<specific version (optional)>\" ) case \"rhel\" : package . install ( \"<specific rhel/centos pacakge>\" , \"<specific version (optional)>\" ) case \"alpine\" : package . install ( \"<specific alpine pacakge>\" , \"<specific version (optional)>\" ) }","title":"Packages"},{"location":"Config%20Management/modules/#files--directories","text":"When configuring a box, it is almost always required to write a configuration file to a path eg. /etc/someapp/somedir While other scripting languages provide this functionality, orcascript has went above and beyond to make this as easy as possible, with as little code as possible. The orcascript stdlib ships with an os module that provides methods such as isfile , isdir , mkdir , read , write and many, many more, that will handle all of the the operations that come with managing a filesystem. In addition to the os module, the stdlib also ships with a template module that provides template related methods such as render that will allow scripts to easily render templated configuration files in their proper directories, with the desired contents in place. For example, if you needed to create a file, ie /etc/some-app/some.conf , you could use the template module like so: // read in our example template file to a variable called 'tpl' tpl := os . read ( \"/path/to/my/config.tpl\" ) // define some example vars, // NOTE: you can load vars from many different sources. // NOTE: they don't have to be inline, like this. vars := { \"somekey\" : \"someval\" , \"someOtherKey\" : \"someOtherVal\" } // once you have a template, and some vars, you can use the render method. // this will write the file to the specified path, with the desired values // injected into the formatted template. template . render ( tpl , vars , \"/etc/some-app/some.conf\" ) Orcascript strives very hard to make it easy to manage any file system related task that you might encounter while attempting to write automation.","title":"Files &amp; Directories"},{"location":"Config%20Management/modules/#services","text":"The final \"general\" category that configuration management tasks usually fall into are services. You may need to start, stop, restart or check the status of a given service. Orcascript makes this easy! Yep, you probably guessed it. The orcascript stdlib ships with a service module that exposes methods for each of those common operations. Orcascript also provides an additional abstraction layer across the various system managers. This includes, System V, systemd and others. Here are some examples of the methods that the service module provides: service . start ( \"<serviceName>\" ) service . stop ( \"<serviceName>\" ) service . restart ( \"<serviceName>\" ) service . status ( \"<serviceName>\" ) service . enable ( \"<serviceName>\" ) service . disable ( \"<serviceName>\" ) service . isup ( \"<serviceName>\" ) service . isdown ( \"<serviceName>\" )","title":"Services"},{"location":"Config%20Management/state/","text":"Declartive State Definitions A declaritive state definition will determine exactly what state the machine executing the orcascript should be in. These definitions, by design, allow for idempotent execution. By declaring the desired state, you can run and re-run the given script as often as necessary to ensure the machine stays in the desired state. If the machine is already in the desired state, no action will be taken. Any part of the machine that is not in the desired state will be reconfigured to the desired state whenever the script runs.","title":"Declaritive State Definitions"},{"location":"Config%20Management/state/#declartive-state-definitions","text":"A declaritive state definition will determine exactly what state the machine executing the orcascript should be in. These definitions, by design, allow for idempotent execution. By declaring the desired state, you can run and re-run the given script as often as necessary to ensure the machine stays in the desired state. If the machine is already in the desired state, no action will be taken. Any part of the machine that is not in the desired state will be reconfigured to the desired state whenever the script runs.","title":"Declartive State Definitions"},{"location":"Event%20Management/","text":"Intro This section will go over how we can use orcascript , along with orcaem to provide Event Management capabilities. The orcaem agent allows you monitor your systems and automate responses to events as they occurr on the host. A Simple Example Lets say that you want to watch the /var/logs/nginx/error.log file and when it reaches a certain size, you want to rotate the log. Using orcaem you would define a condition that says \"when log file error.log is <n> MB in size, execute rotate-error-log.orca . When the condition is met, the response system within orcaem would automatically execute the rotate-error-log.orca script and the log would be rotated. As you can see, this tool can be very useful for SRE related automation tasks, as well as security focused operations.","title":"Intro"},{"location":"Event%20Management/#intro","text":"This section will go over how we can use orcascript , along with orcaem to provide Event Management capabilities. The orcaem agent allows you monitor your systems and automate responses to events as they occurr on the host.","title":"Intro"},{"location":"Event%20Management/#a-simple-example","text":"Lets say that you want to watch the /var/logs/nginx/error.log file and when it reaches a certain size, you want to rotate the log. Using orcaem you would define a condition that says \"when log file error.log is <n> MB in size, execute rotate-error-log.orca . When the condition is met, the response system within orcaem would automatically execute the rotate-error-log.orca script and the log would be rotated. As you can see, this tool can be very useful for SRE related automation tasks, as well as security focused operations.","title":"A Simple Example"},{"location":"Secrets%20Management/","text":"Lockbox","title":"Intro to Lockbox"},{"location":"Secrets%20Management/#lockbox","text":"","title":"Lockbox"},{"location":"Syntax%20Guide/","text":"Orcascript Syntax Guide Welcome to the Orcascript Syntax Guide. Orcascript is an interpretted scripting language designed for orchestration and automation tasks. Orcascript has a C style syntax, so if you are already familiar with Python or Javascript, then picking up Orcascript should be VERY easy!","title":"Syntax Guide"},{"location":"Syntax%20Guide/#orcascript-syntax-guide","text":"Welcome to the Orcascript Syntax Guide. Orcascript is an interpretted scripting language designed for orchestration and automation tasks. Orcascript has a C style syntax, so if you are already familiar with Python or Javascript, then picking up Orcascript should be VERY easy!","title":"Orcascript Syntax Guide"},{"location":"Syntax%20Guide/modules/","text":"Module Index Standard Library Modules Module Description os create and remove directories, read from and write to files service manage service related operations for systemd unit files and systemV init scripts, such as start, stop, restart, enable, and disable services running on the host. package interact with underlying package managers to install, uninstall, upgrade, and otherwise manage host level packages. template render templates with variables (useful for plopping down config files with seeded values) host get host level information from this module, such as the underlying os type, mem, disk and cpu usage, and more. npm wrapper to assist in executing npm commands pip wrapper to assist in executing execute pip commands git wrapper to assist in executing execute git commands ssh wrapper to assist in executing execute ssh commands cmd securely execute and manage raw shell commands on the host http a native http/https client logs provides some log parsing methods to interact with log files on the host watch watch files, directories, services, and respond to various events on the host","title":"Module Index"},{"location":"Syntax%20Guide/modules/#module-index","text":"","title":"Module Index"},{"location":"Syntax%20Guide/modules/#standard-library-modules","text":"Module Description os create and remove directories, read from and write to files service manage service related operations for systemd unit files and systemV init scripts, such as start, stop, restart, enable, and disable services running on the host. package interact with underlying package managers to install, uninstall, upgrade, and otherwise manage host level packages. template render templates with variables (useful for plopping down config files with seeded values) host get host level information from this module, such as the underlying os type, mem, disk and cpu usage, and more. npm wrapper to assist in executing npm commands pip wrapper to assist in executing execute pip commands git wrapper to assist in executing execute git commands ssh wrapper to assist in executing execute ssh commands cmd securely execute and manage raw shell commands on the host http a native http/https client logs provides some log parsing methods to interact with log files on the host watch watch files, directories, services, and respond to various events on the host","title":"Standard Library Modules"},{"location":"Task%20Management/","text":"Intro This section will go over how we can use orcascript & orcasrvr as a Task Management System. The orcasrvr provides a task management and execution system over a REST API. For clarification, a task is simply an orcascript that you would like to run. Anything you can write within Orcascript can be a Task. There are 2 methods to trigger a TaskRun within orcasrvr . The first trigger is REST API invocation. Sending a POST request to /tasks/:id/runs will run the given task. The second trigger is Scheduled invocation. You can also manage a Task's schedule via the REST API.","title":"Intro"},{"location":"Task%20Management/#intro","text":"This section will go over how we can use orcascript & orcasrvr as a Task Management System. The orcasrvr provides a task management and execution system over a REST API. For clarification, a task is simply an orcascript that you would like to run. Anything you can write within Orcascript can be a Task. There are 2 methods to trigger a TaskRun within orcasrvr . The first trigger is REST API invocation. Sending a POST request to /tasks/:id/runs will run the given task. The second trigger is Scheduled invocation. You can also manage a Task's schedule via the REST API.","title":"Intro"}]}